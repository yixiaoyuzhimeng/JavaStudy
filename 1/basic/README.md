# Java学习笔记（在C语言基础上）



## 参考视频：[求知讲堂Java视频](https://www.bilibili.com/video/BV1CJ411m7gg/?spm_id_from=333.337.search-card.all.click&vd_source=862f1dfe1de86939f09fef7b03e32339)



## 基础常识
### （一） 软件开发的概念		
### （二） 交互手段
#### 	(1)UI 图形界面；
####	(2)DOS 命令行界面：窗口键+r  —— 输入cmd —— 打开DOS命令
		Dir  列出当前目录下的文件以及文件夹
		md	创建目录
		rd	删除目录
		cd  进入指定目录
cd ..	退回到上一级目录
		cd \	退回到根目录
		del	删除文件
		exit	退出DOS命令
	（注意：所有输入都要在英文输入法下）
### （三）	JAVA概述
#### （1）	机器语言（打孔机）—— 汇编 —— 高级语言(面向过程->面向对象->……)
#### （2）	JAVA的产生（java命名？HelloWorld由来?）
#### （3）	JAVA技术体系平台——SE/EE/ME/Card
#### （4）	JAVA运行机制——核心机制有JVM和GC
#### （5）	JVM内存模型
栈stack
	基本数据类型
	对象的引用（地址）
堆heap
	所有对象（包括自己定义的对象和字符串对象）
方法区method
	所有的class和static变量
字符串常量池
（6）	JDK>JRE>JVM,环境变量的配置，编写编译运行，规则，常见错误与解决，
（7）	使用：电脑自带记事本->文本编辑器->集成开发工具
（8）	注释：
多行注释 Ctrl+Shift+/                 取消 Ctrl+Shift+\
单行注释 Ctrl+Shift+c 或者 Ctrl+/      取消 Ctrl+Shift+c 或者 Ctrl+/
（9）	输出
简写为sysou
（10）	Main方法简写
## 基本语法
### 1.	关键字（<-保留字）
### 2.	标识符
（1）	命名： 英文大小写、 $、 数字（不能开头）
（2）	包名全小写，
类名接口名首字母大写，
变量名方法名驼峰命名法， 
常量名全大写
### 3.	变量
（1）	在内存中的一个存储区域（有变量名和类型）
（2）	注意有效范围
（3）	必须初始化值【？】（否则不能用吧。但是如果刚开始只声明并不会报错）

方法内定义的数据成员称为变量，
JVM不负责初始化，
一定要自己赋初值；
但是数组动态初始化时也会由JVM自动添加默认值。

而类里定义的数据成员称为属性（成员变量），
属性可不赋初值，
若不赋初值则JAVA会按上表为其添加默认值
### 4.	数据类型（基本和引用）
（1）	基本类型
Byte\short\int\long\float\double\char\boolean
（2）	基本数据类型转换
自动转换（小->大）
	byte\short\char不能相互转换，但是能在计算时都转换为int类型
	子类父类
强制转换（大->小）
	Bool类型不能转换为其他，并且只有true或faluse两种情况
	父类->子类
（3）	引用类型：都可以用null作为值
String类，值不可变，创建出来的字符串就存放在字符串常量池（堆内存？），保证每个字符串常量只有一个，不会产生多个副本。
String s=”hello”;
声明s变量时给s赋值”hello”实际上让s变量引用“hello”内存
（4）	用+连接基本数据类型和字符串时，基本数据类型->（自动转换）为字符串
注意从左到右的运算顺序，在没有遇到字符串前仍进行计算
（5）	字符串->基本数据类型，需要通过基本类型对应的包装类
### 5.	运算符
（1）	算术
/ 两个整数相除仍保留整数
如果对负数取模%，可以把模负号忽略；取模结果不一定是整数。
+既可以实现字符串相加，也可以把非字符串转化为字符串（区别于C语言）
（2）	赋值
若short s=2;
s+=3;扩展赋值运算可以自动强制转换为所需类型
s =(short)(s+3); 而这样必须手动强制转换
（3）	比较 
区分==和=
（4）	逻辑
区分&&和&
区分||和|
前者会惰性求值
（5）	位(直接对二进制运算)
十转二   ->  除二取余，整数从下到上，小数从上到下
二转十  ->  乘二……
正数 -> 反码 -> +1（补码）-> 负数 
<<左移一位*2，>>右移一位/2
>>>无符号右移，与正数的>>右移一致，与负数的右移>>不一致
右移后空出的位置看右移前的首位，是0则补0，是1则补1；
无符号右移空出的位置均为1
&运算，都是1才是1
|运算，都是0才是0
^运算，均为0或1时结果为0，否则为1
~运算，把1变0，0变1
（6）	三元（目）运算符
（7）	运算符的优先级
### 6.	程序流程控制
（1）	顺序语句
（2）	分支语句
If(){;}else{;}
Switch(表达式) case 常量：{}     
注意表达式的返回值必须是byte\short\char\int\string\枚举
（3）	循环语句
for
while
do while
嵌套循环（尽量保证外层循环次数小于内层循环次数）
（4）	特殊流程控制
break     用于跳出所在的switch和循环语句中，不对if语句起作用
continue  用在终止当前循环，直接进行下一次循环
return	   用于结束方法
### 7.	数组
（1）	数组的声明
Int[] I;
Int i[];
（2）	初始化
2.1静态初始化：
Int a[]=new int[]{3,4};
Int[] a={3,9,8};
2.2动态初始化：
Int[] a=new int[3] 会自动赋默认值
a[0]=1;
a[1]=2
（3）	二维数组，每个元素是一个数组
Int[][] i=new int[][]{{1,2},{3,4}}
Int[][]  i=new int[2][3];
Int[][] i=new int[2][];可以只定义第一位的长度，不定义第二维的长度
（4）	
	

### 8.	字符串
（1）	String类
（i）	静态初始化 String str = “abc” ;    （享元模式Schema）
字面量创建
（ii）	动态初始化 String str2=new Stirng(“abc”) ;
new创建，比字面量创建多了个堆中的对象，多占些内存
（iii）	String对象的创建
（1）	字面量创建(比用new创建省内存)
String s1=”abc”;
堆内存中有字符串常量池，
通过字面量创建时，
会首先通过equals判断是否池中有对应字符串，
若有，直接指向，
若无，在常量池中创建一个，再返回相应的引用。
（2）	New创建
String s3=new String(“abc“)；
若常量池中没有对应字符串，
则在常量池中添加，
并在堆中创建一个对象，
返回指向堆中的引用；
若有，
则不再添加，
但仍在堆中另外创建一个对象，
返回指向堆中的引用。
（3）	通过+连接符直接创建
String s5=”x”+”y”;
（4）	String s6=new String(“1”)+new String(“2”);
通过StringBuilder实现。
在常量池中添加“1“和”2“两个对象，
在堆中创建值为”112“的对象，
再把引用地址给s6
（iv）	
（v）	

（2）	StringBuffer类
（3）	StringBuilder类

## 面向对象
### 1．	Java类以及类的成员
（1）	变量——
	成员变量（在方法外、类体内声明的）：
		若以static修饰是类变量（直接通过类名.属性直接调用，当然也可以通过实例化变量进行调用，为一个类的所有实例变量所共享），
		不以static修饰是实例变量（只能在类实例化为对象后才能使用），实例变量存放在对象的堆内存中
			包含匿名对象：
				直接实例化一个类，并调用方法，而不声明对象名
				经常将匿名对象作为实参传递给一个方法调用；
	局部变量：（声明时不指定权限修饰符）存放在栈内存中
		在方法签名中定义的是形参，
		在方法内定义的是方法局部变量，
		在代码块内定义的是代码块局部变量
（2）	类中要有属性（成员变量）和行为（方法/函数），
有时候也有构造函数、代码块、内部类
	类的成员变量有默认值，可以先不用初始化
（3）	自定义类的步骤
	定义类（考虑修饰符、类名）
	编写属性（考虑修饰符、属性类型、属性名、初始化值）
	编写类的方法（考虑修饰符、返回值类型、方法名、形参等）
	编写构造方法……
（4）	对象的创建和使用
	实例化一个类（new+构造器创建个对象）
（5）	详解属性（成员变量）
（a）	修饰符 类型 属性名=初值；
（b）	 Private 私有，只能在当前类使用，
通过方法getXxx()或 SetXxx()而不是对象.属性的方式调用
（6）	详解方法（基本方法就是一个
（a）	方法必须在类中定义：
用static修饰的属于类，
没有static则属于对象
（b）	方法只有在被调用时才会被执行； 
（c）	与C语言的函数一样，
		方法可以嵌套调用，但不能嵌套定义；
（d）	类中的方法可以直接访问类中的成员变量,
		但是static方法不能直接访问非static变量；只能通过构造实例访问
		非静态方法可以访问静态和非静态成员
（e）	方法的重载overload
		在一个类中，参数的个数或者数据类型不同的同名方法
		但是返回值类型和访问限制不影响
（f）	方法中传递可变个数的参数
		用数组方式
		用java特有的…方式（可以传递0到多个参数）
		如果一个方法有多个形参，可变的形参要放在所有参数最后
（g）	  参数传递（java里参数只有值传递，即变量在栈内存中的值）
			基本数据类型(均保存在在栈内存中)
				把实参的值复制给形参
			引用对象（在栈中保存的是其地址）
				传递给形参的是实参在栈内存中的值，
				也就是引用对象的在堆内存中的地址
（h）	常见问题1：
当一个对象被当作参数传递到一个方法后，
此方法可改变这个对象的属性，
并可返回变化后的结果，
那么这里到底是值传递还是引用传递?
解答：
是值传递。
Java 编程语言只有值传递参数。
当一个对象实例作为一个参数被传递到方法中时，
参数的值就是对该对象的引用。[?]
对象的内容可以在被调用的 方法中改变，
但对象的引用是永远不会改变的。

（7）	构造方法
名称必须和类名相同
没有返回值
（8）	Package包
		即文件夹，便于管理和解决文件重名问题
		层级结构用.指明
		运行程序时，要将当前目录设置为最外层的包文件夹所在的目录，而不是类文件所在的目录
Import引用
		用于不同包下的类
		三种方法
（9）	初始化块（代码块）
（a）	作用：对Java对象初始化
（b）	注意：静态代码块中只能使用static修饰的属性和方法
（c）	在程序运行过程中，
非静态代码块每次new对象时都会重新执行，
而静态代码块只执行一次，且先于非静态代码块
（d）	在实际开发中，静态代码块运用更多，用于初始化类的静态属性
（10）	内部类
（a）	声明为static时，不能用外层类的非static成员
（b）	内部类也可声明为抽象的，可被继承
（c）	可通过创建内部类实现多重继承
（d）	成员内部类（类中），包含静态内部类
（e）	Otter out = new Outter();            外部类Otter
Outter.Inner in = out.new Inner()     非静态Inner
Outter.Inner2 in2=new Otter.Inner2()  静态  Inner2
（f）	成员内部类可以声明为private或protected，
（g）	若在外部类外创建成员内部类时，要先创建外部类的实例，通过实例来创建内部傀儡的实例 
（h）	局部内部类（方法中），包含匿名内部类
（i）	局部内部类和局部变量相似，不能有访问说明符，不是外部类的一部分 
（j）	局部内部类除了访问内部类的成员变量，也可以直接访问外部类的成员变量。（形式是：外部类.this.外部类成员变量） 
（k）	匿名内部类在声明类的同时创建了对象。它的声明要么是基于继承的，要么是实现接口的
### 2．	面向对象的三大特征
（1）	封装和隐藏 
(javabean）
声明为private，
提供public方法getXxx()和setXxx()实现对属性的操作
（2）	继承
(a)	要有逻辑关系，不要随意继承；
(b)	子类继承父类的方法和属性，也可以创建新的方法和属性，
子类是父类的扩展；
(c)	Java支持单继承，可以多层继承，但不能多重继承
(d)	可通过内部类实现多重继承
(e)	可通过接口实现多重继承
（i）	接口由interface定义，用implements实现该接口
（ii）	接口中成员变量默认是public static final，（即使声明时没有写，系统也会自动加上，因为接口只能有常量）
（iii）	方法默认是public abstract
（iv）	没有构造器
（v）	接口可以继承（extends）多个接口，不能继承类
（vi）	父类需要稳定的抽象，否则所有子类都会受影响。若要给父类增加方法，需要新建一个接口，在接口上扩展方法，其他需要的子类自行实现接口
（vii）	接口类型的引用可以指向任何实现自接口或子接口的类，可以访问指向对象中实现自接口的方法。
（viii）	如果实现接口的类没有实现接口中的全部方法，需将该类定义为抽象类。
（ix）	接口是对方法的抽象，
抽象类是对一类事物的高度抽象。
（x）	
(f)	override,（重写/覆盖）
（i）	重写成员变量时会发生隐藏（什么时候不隐藏？），除非用super调用父类成员的成员变量
（j）	子类重写父类的方法时，
只重写编写方法体的代码
且不能使用比重写方法更严格的访问权限
返回类型：基本数据类型要相同；对象引用类型相同或子类
快捷键（Alt+/）
(g)	子类继承父类
	若子类重写父类方法，则子类定义的方法彻底覆盖了父类的同名方法，系统将不可能把父类里的方法转移到子类中；
但实例变量不会出现覆盖（？与上方的隐藏的有什么区别？为什么？），即使子类的和父类的实例变量同名。
(h)	Object类（根父类）
主要方法
equals     引用对象比较
hashCode  取得Hash码
toString    打印当前引用的对象所在的内存地址
（若要输出新的字符串，则需要重写toString方法,
打印一个对象，相当于打印这个对象调用toString方法的返回值。）
在自己写的类中，最好重写equals和toString方法
(i)	. 引用类型变量的地址备份用赋值语句实现,
引用类型(对象)的备份用Object类中的clone ()方法实现。
(j)	
(k)	.
（3）	多态（？）
(a)	 前提：
存在继承或实现关系；要有覆盖操作
成员方法：（动态绑定，前提是有方法的重写）
	编译时，要查看引用变量所属的类中是否有所调用的方法
	运行时，调用实际对象所属的类中的重写方法（只能使用重写方法，而不能使用自己新增的方法？bingo!向上转型时还是只能用父类延伸下来或者崇明的方法和属性，不能用新增的）
			若当前子类无改名方法，则会追溯父类
成员变量：
	不具有多态性，只看引用变量所属的类
(b)	方法的多态：重写和重载
	虚拟方法的调用:
		Java的方法运行在栈内存中，
		在运行方法时会动态地进栈和出栈、
	若方法声明的形参为父类类型，
		可以使用子类对象作为实参调用该方法。
(c)	对象的多态性：编译时和运行时类型不同时。
(i)	编译时类型由声明该变量时的类型决定；
		运行时类型由实际赋给该变量的对象决定。
(ii)	把子类看成是特殊的父类，
子类对象可以代替父类对象使用
一个变量只能有一种确定的数据类型
一个引用变量可以指向多种不同类型的对象
(iii)	（自动转换）向上转型upcasting：
父类的引用可以指向子类的对象。
从子类到父类的类型可以自动转换。
Animals animals=new Fish();
由于属性实在编译时确定，方法是在运行时确定，
所以使用父类的属性Animals，调用的是子类的方法Fish
(iv)	（强制转换）向下转向(在上溯的基础上)
子类的引用指向父类对象。
从父类到子类的转换需要强制转换
Fish fish=(Fish) anmals
(v)	无继承关系的引用转换时非法的
(vi)	
。
(d)	.
(e)	.
(f)	/
（4）	.
（5）	.
### 3．	其他关键字
(1)	权限修饰符
（a）	类的权限修饰符只有public或者缺省
一个文件中可以有多个类，但只有一个是public，其余都是缺省
（b）	成员变量的有public\protected\private
（c）	权限       作用范围
Private     类内部
缺省的     当前包
Protected   当前包及其不同包下的子类
Public      全局
（6）	this
 *形参与成员变量重名时，
 若在方法内部 使用成员变量，
 需要添加this来表明该变量时类成员
 * 在任意方法内，
 若使用当前类的成员变量或成员方法，
 可以在其前面添加this，增强程序阅读性
 * 在一个类中，
 this()作为构造器相互调用的特殊形式
 this()必须放在调用的构造器的首行，
 且必须保证至少有一个构造器不用this(),
 	  自己也不能调用自己（禁止套娃）
（7）	super
（a）	当子父类出现同名成员时，可以用super进行区分
（b）	Super的追溯不仅限于直接父类
（c）	子类所有构造器默认都会访问父类中空参数的构造器
（d）	当父类没有空参数的构造器时，（？）
子类的构造器必须通过this（参数列表）调用本类相应构造器，用super（参数列表）调用父类参数构造器，
并且调用的构造方法要写在第一行（this和super只能选一个）。
（e）	this可以表示当前对象，super没有此概念。
this首先访问本类属性，若没有，则从父类中继续查找；
而super只能访问父类属性。
This首先访问父类方法（？本类吧）,super直接访问父类方法
（f）	 .
（8）	x instanceof A
检验实例对象x所属的类（即实例化的类）是否是
A类或者A类的子类（即衍生）
（9）	equals与==的区别
（a）	==符号两边的数据类型必须兼容（？）
（除了可自动转换基本本数据类型）
==可以比较基本数据类型对象的值，
和引用类型对象的引用值（实际内存地址）
（b）	Equals只能比较引用类型，作用与==同，
均比较是否指向同一个对象
（c）	特别的是，equals比较类File\String\Date\WrappingClass时，
只比较内容，因为这些类中重写了Object方法。
（d）	两个对象值相同(x.equals(y) ==true)，有相同的hashcode。
（e）	
（10）	Wrapper 
（a）	（装箱）基本数据类型包装成包装类
Int i=500;
Integer t=new Integer(i);//通过包装类的构造器
Float f=new Float(“4.5”)//通过字符串参数，必须和基本类型匹配
（b）	（拆箱）
int m=t.intValue();
（c）	自动装箱和拆箱
（d）	字符串转基本数据类型
Int i=new Integer(“12”);//通过包装类的构造器
Float f =Float.parseFloat(“12.1”)//通过包装类的静态方法
（e）	基本数据类型转字符串
String str=String.valueOf(2.34f);//字符串重载的valueOf方法
String intStr=5+””;//更直接的方法
（f）	.
（g）	.
（11）	Static 
被static修饰的变量是类变量，同理是类方法，
被该类所有实例化对象所共享。
Static可以修饰类的属性、方法、代码块、内部类。
被修饰后，
随着类的加载而加载；
优先于对象存在；
修饰的成员被所有对象共享；
访问权限允许时，可以不创建对象直接被类调用。
Static方法内部不能有this/super，且只能直接访问类的static属性（？）
（12）	Final
Final类不能被继承，比如String\Stste\StringBuffer
Final方法不能被重写,比如Object中的getclass()
Final变量成为常量，只能被赋值一次;
Final static 一起修饰变量，就是全局常量。
（13）	Abstact
含有抽象方法的类必须声明为抽象类；
抽象类可以有构造方法不能被实例化，只能被继承。
抽象类用来模型化那些父类无法确定全部实现，而由子类提供具体实现的对象的类。
（14）	.

（15）	. 

（16）	.

### 4．	实例化过程
（a）	简单对象实例化过程
(1)	在方法区加载person.class
(2)	在栈中申请空间，声明变量p
(3)	在堆内存中开辟空间、分配地址，假设地址是BE2500
(4)	在堆内存的对象空间中，对对象的属性进行默认初始化，再进行类成员变量的 初始化
(5)	构造函数方法进栈，进行初始化
(6)	初始化完毕后，将堆内存中的地址值给引用变量，构造方法出栈
（b）	子类对象实例化过程
（1）	在方法区先加载Person.class,再Student.class（先父类后子类）
（2）	在栈中申请空间，声明变量stu
（3）	在堆内存中开辟空间，分配地址，假设地址是BE2500
（4）	在堆内存中的对象空间里，对对象中的属性进行默认初始化（子父类）
（5）	子类构造方法进栈
（6）	显示初始化父类的属性
（7）	父类构造方法进栈，执行完毕出栈
（8）	显示初始化子类的属性
（9）	初始化完毕后，将堆内存中的地址值赋给引用变量，子类构造方法出栈
（c）	String对象的创建
（5）	字面量创建(比用new创建省内存)
String s1=”abc”;
堆内存中有字符串常量池，
通过字面量创建时，
会首先通过equals判断是否池中有对应字符串，
若有，直接指向，
若无，在常量池中创建一个，再返回相应的引用。
（6）	New创建
String s3=new String(“abc“)；
若常量池中没有对应字符串，
则在常量池中添加，
并在堆中创建一个对象，
返回指向堆中的引用；
若有，
则不再添加，
但仍在堆中另外创建一个对象，
返回指向堆中的引用。
（7）	通过+连接符直接创建
String s5=”x”+”y”;
（8）	String s6=new String(“1”)+new String(“2”);
通过StringBuilder实现。
在常量池中添加“1“和”2“两个对象，
在堆中创建值为”112“的对象，
再把引用地址给s6
（9）	.
### 5．	单例设计模式
（1）	设计模式就是套路
（2）	单例是只有一个实例化对象
（3）	单例设计模式即：
在整个软件系统运行过程中，
这个类只能被实例化一次，
以后不论在哪都只调用这一个实例
有两种模式，区别在于什么时候new对象
（4）	使用情况：一般new对象太费劲，
或者频繁new对象没必要
（5）	懒汉式：
第一次有人调用fetInstance方法时来new对象，以后再调用该方法时就直接返回第一次new好的对象；
Private 构造方法
Private 自身成员变量（先赋值null）
Public staic 方法返回自身成员变量（用If语句new第一次调用时的成员变量）【
（6）	饿汉式：
在类加载之后，调用之前，就先new好一个对象，以后调用该方法时均直接返回new好的对象
Private 构造方法
Private 自身成员变量（new出来的）【
Public static方法返回 自身成员变量
实例化对象时就不用new,而直接调用这个类的公有静态方法
### 9.	模块方法设计模式
抽象类作为多个子类的通用模板
提供了多个子类的通用方法，
并把不确定的部分暴露出去让子类实现
### 10.	工厂模式
对象创建的时机很重要，工厂方法将所要创建的具体对象的创建工作延迟到了子类，从而提供了一种扩展的策略，较好解决了紧耦合的关系
通过工厂把new对象给隔离，通过产品的接口可以接收不同实际产品的实现类，实例的类名改变不影响其他合作开发人员的编程
### 11.	

## 其他
### （一）	异常

（1）	Error
（2）	Exception（程序员只能处理）
Runtime
	 I/0
（3）	异常处理机制 
a.	捕获：
一个方法内抛出的异常，会被抛到调用方法中，若未被调用方法处理，则会被继续向上抛，直到一场被处理
	Try{……} catch{……} finally{……}
	(可有可无,最终都会执行finally{})
b.	抛出：
程序执行时出现异常会自动生成一个异常类对象，该一场类对象会被提交给Java运行时程序
Throw

	子类重写父类方法时，不能抛出比父类类范围更大的异常
	
（4）	抛出异常的三种形式：
系统自动抛出
使用throw语句抛出的异常
抛出异常的方法
（5）	异常信息的显示
getMessage() 
toString()
printStackTrace()
（6）	 
（7）	 
（8）	
### （二）	集合
1.	集合类存放在java.util包中，只能存放对象的引用，可以存放不同类型不限次数的数据类型
2.	可分为Set(无序、不可重复)List(有序、可重复)Map(有映射关系) 
3.	HasSet :
(1)	按照Hash算法存储集合中的元素
	不是线程安全的
	集合元素可以是null
	存在set集合那个位置由这个值的hashcode决定
	不可重复，指的是hashcode不相同 
(2)	HashSet<String> hs=new HashSet<String>();
<String>代表Generic即泛型 ,表示HashSet中元素的类型。
4.	TreeSet 
5.	ArrayList
					默认按照元素的添加顺序来设置元素的索引
					可以通过索引来访问指定位置的集合元素
					不是线程安全的
					
（1）	，
（2）	
（3）	 

### （三）	泛型
### （四）	I/O
1.	路径分隔符window下“\”，linux和unix下“/”
2.	缓冲流基于对内存的操作
3.	文件流基于对文件的操作
（1）	不能访问文件本身，需要输入输出流访问
（2）	
4.	转换流、标准输入输出流、打印流、数据流、对象流、随机存取文件流
### （五）	反射机制
### （六）	线程
1.	几核的CPU就代表同一瞬时时间能处理任务数
主频使CPU频繁切换
2.	进程相当于一条河流，线程相当于河流分支
3.	实现线程的两种方式
（1）	继承thread
（2）	实现Runnable接口的 方法
4.	线程的生命周期：新建-就绪-阻塞-运行-死亡
5.	线程的同步
（1）	多线程执行不缺定性，引起执行结果的不稳定
6.	线程的同步2
（1）	Synchronized只能标识方法和对象，不能表示成员变量，不存在同步的成员变量
（2）	一个对象可以同时有同步与非同步方法，但只有一个锁，切只有进入同步方法执行才需要获得锁；
（3）	当线程在访问对象的某个同步方法时，其他线程不能访问该对象的任何同步方法，但可访问非同步方法
（4）	同步方法退出时，锁自动释放，其他等待的线程将获得锁
7.	线程的调度
（1）	优先级
8.	其他方法
（1）	Wait（）会释放锁，sleep（）不会
9.	线程最好先释放同步锁，再进行休眠或者让步，否则会严重影响等待锁的线程的执行
10.	 
### （七）	GUI

